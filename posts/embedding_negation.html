<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2023-06-18 Sun 11:51 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Encoding negation in Hennessy-Milner logic</title>
<meta name="author" content="Luca Zaninotto" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="../style.css"/>
<div style="display: none"> \(
\usepackage{stmaryrd}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{ebproof}
\usepackage{mathtools}
\newcommand{\xr}[1]{\xrightarrow{#1}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\llb}{[\![}
\newcommand{\rrb}{]\!]}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\md}{\; . \;}
\newcommand{\td}{\; : \;}
\newcommand{\sqsb}{\sqsubseteq}
\newcommand{\lub}{\text{lub}}
\newcommand{\lfp}{\text{lfp}}
\newcommand{\glb}{\text{glb}}
\newcommand{\gfp}{\text{gfp}}
\newcommand{\fp}{f_{\varphi, X}^\eta}
\newcommand{\fpof}[3]{f_{ #1 , #2}^{ #3 }}
\newcommand{\fpp}{f_{\varphi'}}
\newcommand{\sem}{\llb\varphi\rrb_\eta}
\newcommand{\semof}[4]{\llb #1 \rrb_{ #2 , #3 }^{ #4 }}
\newcommand{\semc}{\llb\varphi^c\rrb_\eta}
\newcommand{\semOne}{\llb\varphi_1(X)\rrb_{\eta[X\rightarrow S]}}
\newcommand{\semTwo}{\llb\varphi_2(X)\rrb_{\eta[X\rightarrow S]}}
\newcommand{\semOnec}{\llb(\varphi_1(X^c))^c\rrb_{\eta[X\rightarrow S]}}
\newcommand{\semTwoc}{\llb(\varphi_2(X^c))^c\rrb_{\eta[X\rightarrow S]}}
\newcommand{\semm}{\llb\varphi\rrb_{\eta[X\to S]}}
\newcommand{\semmc}{\llb\varphi^c\rrb_{\eta[X\to S]}}
\newcommand{\exs}{{\eta[X\rightarrow S]}}
\newcommand{\exf}{{\eta[X\rightarrow \lfp(\fp)]}}
\newcommand{\exF}{{\eta[X\rightarrow \gfp(\fpp)]}}
\newcommand{\sqact}{\left[\text{Act}\right]}
\newcommand{\anact}{\left<\text{Act}\right>}
\newcommand{\procs}{\text{Proc}}
\newcommand{\pprocs}{2^\procs}
\newtheorem{lemma}{Lemma}
\let\emptyset\varnothing
\)</div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="preamble" class="status">
<nav><a id="navbar-home" href="../index.html">üè° Home</a></nav>
</div>
<div id="content" class="content">
<h1 class="title">Encoding negation in Hennessy-Milner logic</h1>

<div id="outline-container-orgf0c7077" class="outline-2">
<h2 id="orgf0c7077">Hennessy Milner Logic</h2>
<div class="outline-text-2" id="text-orgf0c7077">
<p>
Hennessy-Milner Logic (HML) is interesting in the scope of
distributed system as it allows to (retively) simply define
bisimilarity for processes in the Calculus of Communicating Systems
(CCS). The default syntax (without recursion) is:
</p>

<p>
\[\varphi, \psi ::= T \mid F \mid \varphi \wedge \psi \mid \varphi
  \vee \psi \mid \langle a \rangle \varphi \mid [a]\varphi\]
</p>

<p>
We can notice that negation is not part of the logic (\(\neg
  \varphi\) is not defined). Can we define it? The following article
says yes, with some constraints when we add the recursion in the
logic.
</p>
</div>
</div>
<div id="outline-container-org36d87f5" class="outline-2">
<h2 id="org36d87f5">Encoding Negation</h2>
<div class="outline-text-2" id="text-org36d87f5">
<p>
What we have to show is that, given any Hennessy-Milner logic
formula \(\varphi\), the negation \(\varphi^c\) exists and has the
property \(P\models \varphi \iff P \not\models \varphi^c\). Negation
cab ne defined as:
</p>

<p>
\[ T^c = F \quad (\varphi \wedge \psi)^c = \varphi^c \vee \psi^c \quad (\la a \ra \varphi)^c = [a]\varphi^c \]
\[ F^c = T \quad (\varphi \vee \psi)^c = \varphi^c \wedge \psi^c \quad ([a] \varphi)^c = \la a \ra\varphi^c \]
</p>

<p>
To prove it effectively is negation we'll work by induction on the
length \(l\) of a formula \(\varphi\). If \(l=1\):
</p>
<div class="org-center">
<p>
\(P \models T \iff P\not\models F \iff P \not\models T^c\)
</p>

<p>
\(P \models F \iff P\not\models T \iff P \not\models F^c\)
</p>
</div>

<p>
For \(l > 1\):
</p>

<p>
\(\varphi \wedge \psi\):
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">\(P \models (\varphi\wedge\psi)\)</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \models \varphi\) \(\wedge\)  \(P \models \psi\)</td>
<td class="org-right">by definition of \(\varphi \wedge \psi\)</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P\not\models\varphi^c\) \(\wedge\) \(P\not\models\psi^c\)</td>
<td class="org-right">by induction hypothesis</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P\not\in\llb \varphi^c \rrb\) \(\wedge\) \(P\not\in\llb\psi^c\rrb\)</td>
<td class="org-right">by definition of \(\models\)</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \not\in \llb\varphi^c\rrb \cup \llb\psi^c\rrb\)</td>
<td class="org-right">by definition</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \not\in \llb \varphi^c \vee \psi^c \rrb\)</td>
<td class="org-right">by definition of \(\vee\)</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \not\models \varphi^c\vee\psi^c\)</td>
<td class="org-right">by definition of \(\not\models\)</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \not\models (\varphi \wedge \psi)^c\)</td>
<td class="org-right">by definition of \((\varphi \wedge \psi)^c\)</td>
</tr>
</tbody>
</table>

<p>
\(\varphi \vee \phi\):
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">\(P \models (\varphi\vee\psi)\)</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \models \varphi\) \(\vee\)  \(P \models \psi\)</td>
<td class="org-right">by definition of \(\varphi \vee \psi\)</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P\not\models\varphi^c\) \(\vee\) \(P\not\models\psi^c\)</td>
<td class="org-right">by induction hypothesis</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P\not\in\llb \varphi^c \rrb\) \(\vee\) \(P\not\in\llb\psi^c\rrb\)</td>
<td class="org-right">by definition of \(\models\)</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \not\in \llb\varphi^c\rrb \cap \llb\psi^c\rrb\)</td>
<td class="org-right">by definition</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \not\in \llb \varphi^c \wedge \psi^c \rrb\)</td>
<td class="org-right">by definition of \(\wedge\)</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \not\models \varphi^c\wedge\psi^c\)</td>
<td class="org-right">by definition of \(\not\models\)</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \not\models (\varphi \vee \psi)^c\)</td>
<td class="org-right">by definition of \((\varphi \vee \psi)^c\)</td>
</tr>
</tbody>
</table>


<p>
\([a]\varphi\):
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">\(P\models [\alpha]\varphi\)</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P\in [a]\llb\varphi\rrb = \{Q \mid \forall Q \xrightarrow{\alpha} Q' . Q' \in \llb\varphi\rrb\}\)</td>
<td class="org-right">by definition of \([\alpha]\)</td>
</tr>
</tbody>
</table>

<p>
By induction hypothesis \(Q'\in\llb\varphi\rrb \iff
  Q'\not\in\llb\varphi^c\rrb\), since \(\varphi\) is a formula of
length \(l_0 < l\). Therefore \(Q'\in\llb\varphi^c\rrb \iff
  Q'\not\in\llb\varphi\rrb\). Which means
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">\(P\not\in \{Q \mid \exists Q\xrightarrow{\alpha}Q' . Q'\in\llb\varphi^c\rrb\}\)</td>
<td class="org-right">by inductive hypothesis</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P\not\in\la\alpha\ra\llb\varphi^c\rrb\)</td>
<td class="org-right">by definition of \(\la\cdot\ra\)</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P\not\models\la\alpha\ra\llb\varphi^c\rrb (= ([\alpha]\varphi)^c)\)</td>
<td class="org-right">by definition of \(\models\)</td>
</tr>
</tbody>
</table>


<p>
\(\la a\ra \varphi\):
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">\(P\models \la\alpha\ra\varphi\)</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P\in \la\alpha\ra\llb\varphi\rrb = \{Q \mid \exists Q \xrightarrow{\alpha} Q' . Q' \in \llb\varphi\rrb\}\)</td>
<td class="org-right">by definition of \(\la\alpha\ra\)</td>
</tr>
</tbody>
</table>

<p>
By induction hypothesis \(Q'\in\llb\varphi\rrb \iff
  Q'\not\in\llb\varphi^c\rrb\), since \(\varphi\) is a formula of
length \(l_0 < l\). Therefore \(Q'\in\llb\varphi^c\rrb \iff
  Q'\not\in\llb\varphi\rrb\). Which means
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">\(P\not\in \{Q \mid \forall Q\xrightarrow{\alpha}Q' . Q'\in\llb\varphi^c\rrb\}\)</td>
<td class="org-right">by inductive hypothesis</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P\not\in[\alpha]\llb\varphi^c\rrb\)</td>
<td class="org-right">by definition of \([\cdot]\)</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P\not\models[\alpha]\llb\varphi^c\rrb (= (\la\alpha\ra\varphi)^c)\)</td>
<td class="org-right">by definition of \(\models\)</td>
</tr>
</tbody>
</table>

<p>
If we introduce recursion the grammar becomes
\[\varphi, \psi ::= \dots \mid X \mid \mu X . \varphi \mid \nu X . \varphi\]
</p>

<p>
where
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-center">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-right">\(\llb X \rrb\)</td>
<td class="org-center">=</td>
<td class="org-left">\(\eta(X)\)</td>
</tr>

<tr>
<td class="org-right">\(\llb \mu X . \varphi\rrb\)</td>
<td class="org-center">=</td>
<td class="org-left">\(\lfp\left(\fp\right)\)</td>
</tr>

<tr>
<td class="org-right">\(\llb \nu X . \varphi\rrb\)</td>
<td class="org-center">=</td>
<td class="org-left">\(\gfp\left(\fp\right)\)</td>
</tr>
</tbody>
</table>

<p>
with 
\[\eta : \text{Var} \rightarrow 2^{\text{Proc}}\]
\[\fp(S) = \llb \varphi \rrb_\exs\]
</p>

<p>
We can define negation as
</p>

<table>


<colgroup>
<col  class="org-right">

<col  class="org-center">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-right">\((X)^c\)</td>
<td class="org-center">=</td>
<td class="org-left">\(X^c\)</td>
</tr>

<tr>
<td class="org-right">\((\mu X . \varphi)^c\)</td>
<td class="org-center">=</td>
<td class="org-left">\(\nu X^c . \varphi^c\)</td>
</tr>

<tr>
<td class="org-right">\((\nu X . \varphi)^c\)</td>
<td class="org-center">=</td>
<td class="org-left">\(\mu X^c . \varphi^c\)</td>
</tr>
</tbody>
</table>

<p>
We also have to pay attention to the meaning of variables by
modifiying the environment \(\eta\): variables that appear negated
(\(^c\)) have a special meaning, which depends on the meaning of the
un-negated variables:
</p>

<p>
\[\llb X^c \rrb = \eta(X^c) = \procs\setminus\eta(X)\]
</p>

<p>
This opens a problem for the definition of \(\mu X . \varphi\) and
\(\nu X . \varphi\) operators. generally the function \[f_{\varphi,
  X}^\eta(S) = \llb\varphi\rrb_{\eta[X\to S]}\] is monotone, but
\(\varphi = X^c\) is a counterexample to the monotonicity of the
induced function \(\fpof{\varphi}{X}{\eta}\) with negation.
</p>

<p>
By adding the possibility of \(\varphi = X^c\) for some variable
\(X\) defined in the environment \(\eta\), then the base case would
not hold anymore: \[S\subseteq T \not\Rightarrow S^c \subseteq T^c\]
in fact, the opposite would hold: \[T^c \subseteq S^c\] and
therefore monotonicity to define \(\mu X . \varphi\) and \(\nu X
  . \varphi\) would not be guaranteed.  This means that we have to
introduce the restriction of variables appearing positively
(i.e. under an even number of negations, so that in the and they
would be \(\equiv X\)) and introduce a new base case (formulas with
length) \(l = 1\): \[\varphi = X \quad \varphi^c = X^c\] \[\llb
  X\rrb = \eta(X) \quad \llb X^c\rrb = \procs\setminus\eta(X)\] which
means \[P\models X \iff P \not\models X^c\] simply by definition.
The next step is working with induction on the length of the formula
\(\varphi\) for \(\mu X . \varphi\) and \(\nu X . \varphi\).  Let's
start with \[\varphi = \nu X . \varphi_1 \quad \llb \nu X
  . \varphi_1\rrb = \gfp(\fpof{\varphi_1}{X}{\eta})\] which by
knaster-tarski on complete lattices, is \[\llb \nu X
  . \varphi_1\rrb = \bigcup\{ S \subseteq \procs \mid S \subseteq
  \fpof{\varphi_1}{X}{\eta}(S) \} \] In other words \[\llb \nu X
  . \varphi_1\rrb = \bigcup\{ S \subseteq \procs \mid S \subseteq
  \llb\varphi_1\rrb_\exs \} \]
</p>

<p>
By induction hypothesis we know that \[P\models \varphi_1 \iff P
  \not\models \varphi_1^c\] in other words \[P\in
  \llb\varphi_1\rrb_{\eta[X\to S]} \iff P \not\in \llb \varphi_1^c
  \rrb_{\eta[X\to S]}\]
</p>

<p>
So, with some passages
</p>
<table>


<colgroup>
<col  class="org-right">

<col  class="org-left">

<col  class="org-right">
</colgroup>
<tbody>
<tr>
<td class="org-right">&#xa0;</td>
<td class="org-left">\(P\in \bigcup\{S \in \pprocs \mid S \subseteq \semm\}\)</td>
<td class="org-right">&#xa0;</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \in \procs\setminus\procs\setminus\bigcup\{S \in \pprocs \mid S \subseteq \semm\} \)</td>
<td class="org-right">by definition</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \not\in \procs\setminus\bigcup\{S \in \pprocs \mid S \subseteq \semm\} \)</td>
<td class="org-right">by complementarity</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P \not\in \bigcap\{S^c \in \pprocs \mid \semmc \subseteq S^c\}\)</td>
<td class="org-right">by definition</td>
</tr>

<tr>
<td class="org-right">iff</td>
<td class="org-left">\(P\not\in \llb\mu X^c . \varphi_1^c\rrb\)</td>
<td class="org-right">by definition</td>
</tr>
</tbody>
</table>

<p>
Which means in other terms \[P\models \nu X . \varphi_1 \iff P
  \not\models \mu X^c . \varphi_1^c \quad (= (\nu X . \varphi_1)^c)\]
</p>

<p>
The same applies for \[\llb \mu X . \varphi_1\rrb = \lfp (
  f_{\varphi_1}^\eta ) = \bigcap\{S \in \pprocs \mid \sem \subseteq
  S\}\]
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(P \in \bigcap\{S \in \pprocs \mid \semm \subseteq S\} \)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">iff</td>
<td class="org-left">\(P\not\in \bigcup\{S^c \in \pprocs \mid S^c \subseteq \semmc\}\)</td>
<td class="org-left">by definition</td>
</tr>

<tr>
<td class="org-left">iff</td>
<td class="org-left">\(P \not\in \llb\nu X^c .\varphi_1^c\rrb\)</td>
<td class="org-left">by definition</td>
</tr>
</tbody>
</table>

<p>
Which means \[P\models \mu X . \varphi_1 \iff P \not\models \nu X^c
  . \varphi_1^c \quad (= (\mu X . \varphi_1)^c)\]
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Luca Zaninotto</p>
<p class="date">Created: 2023-06-18 Sun 11:51</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
